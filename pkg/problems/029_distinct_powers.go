package problems

import (
	"fmt"
	"sort"
	"strings"
)

type DistinctPowers struct{}

func (p *DistinctPowers) ID() int {
	return 29
}

func (p *DistinctPowers) Text() string {
	return `Consider all integer combinations of a^b for
2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

    2^2=4,  2^3=8,   2^4=16,  2^5=32
    3^2=9,  3^3=27,  3^4=81,  3^5=243
    4^2=16, 4^3=64,  4^4=256, 4^5=1024
    5^2=25, 5^3=125, 5^4=625, 5^5=3125

If they are then placed in numerical order, with any repeats removed,
we get the following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by
a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
`
}

// UInt64List - sort package doesn't have a built-in for uint64 slices
type UInt64List []uint64

func (l UInt64List) Len() int           { return len(l) }
func (l UInt64List) Less(i, j int) bool { return l[i] < l[j] }
func (l UInt64List) Swap(i, j int)      { l[i], l[j] = l[j], l[i] }

// Solve - For each combination of a^b, the expression is
// simplified into a an equivalent prime factorisation and
// then convert into an ordered string.
//
// ex:
//   a^b = 60^5 = "2^10*3^5*5^5"
//
// A map[string]bool is used to track distinct values
func (p *DistinctPowers) Solve() (string, error) {

	N := 100
	distinct := map[string]bool{}

	for a := uint64(2); a <= uint64(N); a++ {
		// generate prime factorization of a
		pf := primeFactors(a)

		// create a sorted list of the base values for a's prime factorization
		keys := make([]uint64, 0, len(pf))
		for k := range pf {
			keys = append(keys, k)
		}
		sort.Sort(UInt64List(keys))

		// for each b value from 2 to N, multiply the exponents and generate
		// the string representation of a^b in prime factorization
		// a = 60 = 2^2*3*5
		// for b = 2; 2^4*3^2*5^2
		// for b = 3; 2^6*3^3*5^3
		for b := 2; b <= N; b++ {
			s := make([]string, 0, len(keys))
			for _, k := range keys {
				exp := pf[k]
				if exp*b == 1 {
					s = append(s, fmt.Sprintf("%d", k))
				} else {
					s = append(s, fmt.Sprintf("%d^%d", k, exp*b))
				}
			}
			distinct[strings.Join(s, "*")] = true
		}
	}

	return fmt.Sprintf("%d", len(distinct)), nil
}
