package problems

import (
	"fmt"
)

type CyclicalFigurateNumbers struct {
	pairs []map[uint64][]uint64
	set   int
}

func (p *CyclicalFigurateNumbers) ID() int {
	return 61
}

func (p *CyclicalFigurateNumbers) Text() string {
	return `Triangle, square, pentagonal, hexagonal, heptagonal, and
octagonal numbers are all figurate (polygonal) numbers and are
generated by the following formulae:

Triangle   P(3,n)=n(n+1)/2   1, 3, 6, 10, 15, ...
Square     P(4,n)=n^2        1, 4, 9, 16, 25, ...
Pentagonal P(5,n)=n(3n-1)/2  1, 5, 12, 22, 35, ...
Hexagonal  P(6,n)=n(2n-1)    1, 6, 15, 28, 45, ...
Heptagonal P(7,n)=n(5n-3)/2  1, 7, 18, 34, 55, ...
Octagonal  P(8,n)=n(3n-2)    1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has
three interesting properties.

1. The set is cyclic, in that the last two digits of each number is
   the first two digits of the next number (including the last number
   with the first).
2. Each polygonal type: triangle (P(3,127)=8128), square (P(4,91)=8281), and
   pentagonal (P(5,44)=2882), is represented by a different number in the set.
3. This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers
for which each polygonal type: triangle, square, pentagonal,
hexagonal, heptagonal, and octagonal, is represented by a different
number in the set.
`
}

func (p *CyclicalFigurateNumbers) trace(pns []int, hops []uint64, hop uint64) bool {
	fmt.Println()
	fmt.Println("polynomial numbers to check", pns)
	fmt.Println("hops thus far", hops)
	fmt.Println("current hop", hop)
	if len(pns) == 0 {
		if len(hops) == p.set && hops[0] == hop {
			fmt.Println("found it")
			fmt.Println(append(hops, hop))
			return true
		}
		return false
	}
	result := false
	for i, pn := range pns {
		pnsLeft := []int{}
		for _, j := range pns[:i] {
			pnsLeft = append(pnsLeft, j)
		}
		for _, j := range pns[i+1:] {
			pnsLeft = append(pnsLeft, j)
		}
		fmt.Println("checking remaining polynomial", pn, "which leaves", pnsLeft)
		if p.pairs[pn][hop] == nil || len(p.pairs[pn][hop]) == 0 {
			fmt.Println("no next hops for hop", hop, "and polynomial", pn, p.pairs[pn][hop])
			return false
		}
		fmt.Println("next hops", p.pairs[pn][hop], "for hop", hop, "in polynomial", pn)
		for _, next := range p.pairs[pn][hop] {
			newHops := make([]uint64, 0, len(hops)+1)
			for _, h := range hops {
				newHops = append(newHops, h)
			}
			newHops = append(newHops, hop)
			result = result || p.trace(pnsLeft, newHops, next)
		}
	}
	return result
}

func (p *CyclicalFigurateNumbers) Solve() (string, error) {
	p.set = 3
	p.pairs = make([]map[uint64][]uint64, p.set)

	for pn := 3; pn < 3+p.set; pn++ {
		fmt.Println(pn, p.pairs, pn-3)
		fmt.Println(p.pairs[pn-3])
		p.pairs[pn-3] = map[uint64][]uint64{}
		n := 1
		for {
			v := PolynomialSequence(pn, n)
			if v >= 1000 && v < 10000 {
				p.pairs[pn-3][v/100] = append(p.pairs[pn-3][v/100], v%100)
			} else if v >= 10000 {
				fmt.Println(pn, v)
				break
			}
			n++
		}
	}

	for hop := uint64(0); hop < 100; hop++ {
		fmt.Println("--------------------------------------")
		hops := []uint64{hop}
		fmt.Println("hop", hop, "has next hops of", p.pairs[0][hop])
		for _, next := range p.pairs[0][hop] {
			pnsLeft := make([]int, 0, p.set-1)
			for i := 1; i <= p.set; i++ {
				pnsLeft = append(pnsLeft, i)
			}
			if p.trace(pnsLeft, hops, next) {
				return "", nil
			}
		}
	}

	// start at 0
	// pad := uint64(81)
	//
	// fmt.Println(pairs[1][pad])
	// fmt.Println(pairs[2][pad])
	//
	// pad = uint64(28)
	//
	// fmt.Println(pairs[0][pad])
	// fmt.Println(pairs[1][pad])
	// fmt.Println(pairs[2][pad])
	//
	// pad = uint64(82)
	//
	// fmt.Println(pairs[0][pad])
	// fmt.Println(pairs[1][pad])
	// fmt.Println(pairs[2][pad])

	return fmt.Sprintf("%d", 0), nil
}
