package problems

import (
	"fmt"
	"log"
	"strconv"
)

type CyclicalFigurateNumbers struct{}

func (p *CyclicalFigurateNumbers) ID() int {
	return 61
}

func (p *CyclicalFigurateNumbers) Text() string {
	return `Triangle, square, pentagonal, hexagonal, heptagonal, and
octagonal numbers are all figurate (polygonal) numbers and are
generated by the following formulae:

Triangle   P(3,n)=n(n+1)/2   1, 3, 6, 10, 15, ...
Square     P(4,n)=n^2        1, 4, 9, 16, 25, ...
Pentagonal P(5,n)=n(3n-1)/2  1, 5, 12, 22, 35, ...
Hexagonal  P(6,n)=n(2n-1)    1, 6, 15, 28, 45, ...
Heptagonal P(7,n)=n(5n-3)/2  1, 7, 18, 34, 55, ...
Octagonal  P(8,n)=n(3n-2)    1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has
three interesting properties.

1. The set is cyclic, in that the last two digits of each number is
   the first two digits of the next number (including the last number
   with the first).
2. Each polygonal type: triangle (P(3,127)=8128), square (P(4,91)=8281), and
   pentagonal (P(5,44)=2882), is represented by a different number in the set.
3. This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers
for which each polygonal type: triangle, square, pentagonal,
hexagonal, heptagonal, and octagonal, is represented by a different
number in the set.
`
}

func (p *CyclicalFigurateNumbers) preload() map[int]map[int][]int {

	sequences := map[int]map[int][]int{}
	for pn := 3; pn <= 8; pn++ {
		n := 0
		seq := map[int][]int{}
		for {
			v := PolynomialSequence(pn, n)
			n++
			if v < 1000 {
				continue
			} else if v >= 10000 {
				break
			}

			if seq[int(v/100)] == nil {
				seq[int(v/100)] = []int{int(v % 100)}
			} else {
				seq[int(v/100)] = append(seq[int(v/100)], int(v%100))
			}
		}
		sequences[pn] = seq
	}
	return sequences
}

func (p *CyclicalFigurateNumbers) pathToSolution(path []string) string {
	solution := 0
	for i := 0; i < len(path); i += 3 {
		val, _ := strconv.Atoi(path[i+1])
		solution += 100 * val
		val, _ = strconv.Atoi(path[i+2])
		solution += val
	}
	return fmt.Sprintf("%d", solution)
}

func (p *CyclicalFigurateNumbers) loadGraph(sequences map[int]map[int][]int) Graph {
	var g Graph
	g = NewGraph()

	for pn, tree := range sequences {
		for branch, leaves := range tree {
			var x Vertex
			x = NewVertex(fmt.Sprintf("%d", branch))
			x = g.AddVertex(x)

			for _, leaf := range leaves {
				var y Vertex
				y = NewVertex(fmt.Sprintf("%d", leaf))
				y = g.AddVertex(y)
				var e Edge
				e = g.AddEdge(x, y, EdgeDirectionTo)
				var pns map[int]bool
				pnIface := e.Get("pn")
				if pnIface == nil {
					pns = map[int]bool{}
				} else {
					pns = pnIface.(map[int]bool)
				}
				pns[pn] = true
				e.Set("pn", pns)
			}
		}
	}
	return g
}

func (p *CyclicalFigurateNumbers) initializePaths(g Graph, sequences map[int]map[int][]int) [][]string {
	paths := [][]string{}
	for pn, sequence := range sequences {
		if pn != 8 {
			continue
		}
		for branch, leaves := range sequence {
			for _, leaf := range leaves {
				paths = append(paths, []string{
					fmt.Sprintf("%d", pn),
					g.GetVertex(fmt.Sprintf("%d", branch)).GetID(),
					g.GetVertex(fmt.Sprintf("%d", leaf)).GetID(),
				})
			}
		}
		break
	}
	return paths
}

func (p *CyclicalFigurateNumbers) generateNextHop(path []string, pn int, edge Edge, v Vertex) []string {
	pnUsed := false
	for idx := 0; idx < len(path); idx += 3 {
		if path[idx] == fmt.Sprintf("%d", pn) {
			log.Printf("skipping pn=%d already used in path %s", pn, path)
			pnUsed = true
			break
		}
	}
	if pnUsed {
		return nil
	}
	id := edge.Y().GetID()
	log.Printf("adding next hop %s -> %s", v, id)
	return []string{
		fmt.Sprintf("%d", pn), v.GetID(), id,
	}
}

func (p *CyclicalFigurateNumbers) nextHop(target int, g Graph, paths [][]string) ([][]string, string, error) {
	newPaths := [][]string{}
	for _, path := range paths {
		v := g.GetVertex(path[len(path)-1])
		edges := v.GetEdges(EdgeDirectionFrom)
		log.Printf("for path %v there are %d edges from vertex %s", path, len(edges), v)
		for _, edge := range edges {
			pns := edge.Get("pn").(map[int]bool)
			for pn, _ := range pns {
				next := p.generateNextHop(path, pn, edge, v)
				if next == nil {
					continue
				}
				newPath := append(path, next...)

				if len(newPath) == target && newPath[len(newPath)-1] == newPath[1] {
					log.Printf("FOUND IT: %s", newPath)
					return nil, p.pathToSolution(newPath), nil
				}
				newPaths = append(newPaths, newPath)
			}
		}
	}
	return newPaths, "", nil
}

func (p *CyclicalFigurateNumbers) Solve() (string, error) {

	sequences := p.preload()
	g := p.loadGraph(sequences)
	paths := p.initializePaths(g, sequences)

	target := len(sequences) * 3

	for {
		newPaths, solution, err := p.nextHop(target, g, paths)
		if solution != "" {
			return solution, err
		}
		if len(newPaths) == 0 {
			log.Printf("error: no valid paths remain")
			return "0", nil
		}
		log.Printf("%d valid paths remaining", len(newPaths))
		for _, path := range newPaths {
			log.Println(path)
		}
		paths = newPaths
	}
}
