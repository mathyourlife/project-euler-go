package problems

import (
	"fmt"
	"strconv"
)

type CyclicalFigurateNumbers struct {
	paths     chan []string
	targetLen int
	solution  chan []string
}

func (p *CyclicalFigurateNumbers) ID() int {
	return 61
}

func (p *CyclicalFigurateNumbers) Text() string {
	return `Triangle, square, pentagonal, hexagonal, heptagonal, and
octagonal numbers are all figurate (polygonal) numbers and are
generated by the following formulae:

Triangle   P(3,n)=n(n+1)/2   1, 3, 6, 10, 15, ...
Square     P(4,n)=n^2        1, 4, 9, 16, 25, ...
Pentagonal P(5,n)=n(3n-1)/2  1, 5, 12, 22, 35, ...
Hexagonal  P(6,n)=n(2n-1)    1, 6, 15, 28, 45, ...
Heptagonal P(7,n)=n(5n-3)/2  1, 7, 18, 34, 55, ...
Octagonal  P(8,n)=n(3n-2)    1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has
three interesting properties.

1. The set is cyclic, in that the last two digits of each number is
   the first two digits of the next number (including the last number
   with the first).
2. Each polygonal type: triangle (P(3,127)=8128), square (P(4,91)=8281), and
   pentagonal (P(5,44)=2882), is represented by a different number in the set.
3. This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers
for which each polygonal type: triangle, square, pentagonal,
hexagonal, heptagonal, and octagonal, is represented by a different
number in the set.
`
}

func (p *CyclicalFigurateNumbers) generateSequences() map[int]map[int][]int {

	sequences := map[int]map[int][]int{}
	for pn := 3; pn <= 8; pn++ {
		n := 0
		seq := map[int][]int{}
		for {
			v := PolynomialSequence(pn, n)
			n++
			if v < 1000 {
				continue
			} else if v >= 10000 {
				break
			}

			if seq[int(v/100)] == nil {
				seq[int(v/100)] = []int{int(v % 100)}
			} else {
				seq[int(v/100)] = append(seq[int(v/100)], int(v%100))
			}
		}
		sequences[pn] = seq
	}
	return sequences
}

func (p *CyclicalFigurateNumbers) pathToSolution(path []string) string {
	solution := 0
	for i := 0; i < len(path); i += 3 {
		val, _ := strconv.Atoi(path[i+1])
		solution += 100 * val
		val, _ = strconv.Atoi(path[i+2])
		solution += val
	}
	return fmt.Sprintf("%d", solution)
}

func (p *CyclicalFigurateNumbers) loadGraph(sequences map[int]map[int][]int) Graph {
	var g Graph
	g = NewGraph()

	for pn, tree := range sequences {
		for branch, leaves := range tree {
			var x Vertex
			x = NewVertex(fmt.Sprintf("%d", branch))
			x = g.AddVertex(x)

			for _, leaf := range leaves {
				var y Vertex
				y = NewVertex(fmt.Sprintf("%d", leaf))
				y = g.AddVertex(y)
				var e Edge
				e = g.AddEdge(x, y, EdgeDirectionTo)
				var pns map[int]bool
				pnIface := e.Get("pn")
				if pnIface == nil {
					pns = map[int]bool{}
				} else {
					pns = pnIface.(map[int]bool)
				}
				pns[pn] = true
				e.Set("pn", pns)
			}
		}
	}
	return g
}

func (p *CyclicalFigurateNumbers) initializePaths(g Graph, sequences map[int]map[int][]int) {
	for pn, sequence := range sequences {
		if pn != 8 {
			continue
		}
		for branch, leaves := range sequence {
			for _, leaf := range leaves {
				go func(path []string) {
					p.paths <- path
				}([]string{
					fmt.Sprintf("%d", pn),
					g.GetVertex(fmt.Sprintf("%d", branch)).GetID(),
					g.GetVertex(fmt.Sprintf("%d", leaf)).GetID(),
				})
			}
		}
		break
	}
}

func (p *CyclicalFigurateNumbers) generateNextHop(path []string, pn int, edge Edge, v Vertex) []string {
	pnUsed := false
	for idx := 0; idx < len(path); idx += 3 {
		if path[idx] == fmt.Sprintf("%d", pn) {
			// log.Printf("skipping pn=%d already used in path %s", pn, path)
			pnUsed = true
			break
		}
	}
	if pnUsed {
		return nil
	}
	id := edge.Y().GetID()
	// log.Printf("adding next hop %s -> %s", v, id)
	return []string{
		fmt.Sprintf("%d", pn), v.GetID(), id,
	}
}

func (p *CyclicalFigurateNumbers) processEdge(edge Edge, path []string, v Vertex) bool {
	pns := edge.Get("pn").(map[int]bool)
	for pn, _ := range pns {
		next := p.generateNextHop(path, pn, edge, v)
		if next == nil {
			continue
		}
		// Avoid race condition
		tmp := make([]string, len(path))
		copy(tmp, path)
		newPath := append(tmp, next...)
		if len(newPath) == p.targetLen && newPath[len(newPath)-1] == newPath[1] {
			// Found the solutions
			p.solution <- newPath
			return true
		}
		go func(pa []string) {
			p.paths <- pa
		}(newPath)
	}
	return false
}

func (p *CyclicalFigurateNumbers) processPaths(g Graph) {
	for path := range p.paths {
		v := g.GetVertex(path[len(path)-1])
		edges := v.GetEdges(EdgeDirectionFrom)
		// log.Printf("for path %v there are %d edges from vertex %s", path, len(edges), v)
		for _, edge := range edges {
			if p.processEdge(edge, path, v) {
				return
			}
		}
	}
}

func (p *CyclicalFigurateNumbers) Solve() (string, error) {

	p.paths = make(chan []string, 100)
	p.solution = make(chan []string)

	sequences := p.generateSequences()
	p.targetLen = len(sequences) * 3

	g := p.loadGraph(sequences)

	p.initializePaths(g, sequences)

	go p.processPaths(g)

	solution := p.pathToSolution(<-p.solution)

	return solution, nil
}
